Syntax:

See processes â†’ ps, top, htop, pgrep, pidof
Manage processes â†’ kill, killall, pkill, fg, bg, jobs
Monitor resources â†’ free, vmstat, iostat, uptime
Schedule jobs â†’ at, cron
Priorities â†’ nice, renice
Debugging â†’ lsof, strace, pstree
Services â†’ systemctl

ps -l â€” Long Format for Current Shell
Shows processes related to the current terminal session.
Output includes detailed info like:
F: Flags
UID: User ID
PID: Process ID
PPID: Parent Process ID
PRI: Priority
NI: Nice value
ADDR: Memory address
SZ: Size
WCHAN: Waiting channel
TTY: Terminal
TIME: CPU time
CMD: Command
ğŸ“Œ Use case: Good for debugging or checking jobs started in the current shell.

ğŸŒ ps -ef â€” Full Format for All Processes
Shows all running processes on the system.
Output includes:
UID: User
PID: Process ID
PPID: Parent PID
C: CPU usage
STIME: Start time
TTY: Terminal
TIME: CPU time
CMD: Command
ğŸ“Œ Use case: Ideal for system-wide process monitoring, scripting, and automation.

ps -aux
Lists all running processes on the system.
Combines BSD-style (aux) options:
a: Show processes for all users.
u: Display user-oriented format (includes user, CPU/mem usage).
x: Include processes not attached to a terminal.
ğŸ§¾ Output Columns:

USER
PID
%CPU
%MEM
VSZ (virtual memory size)
RSS (resident memory size)
TTY
STAT (process state)
START
TIME
COMMAND




Command	Scope	            Format Style	Shows Resource Usage	Includes All Users
ps -l	Current shell only	Long format	              No	         No
ps -ef	All processes	    UNIX style	              No	         Yes
ps -aux	All processes	    BSD style	              Yes	         Yes

pgrep â€“ Find process by name
pgrep ssh      # Get PID of ssh process
pgrep -u user  # Get processes of a user

pidof â€“ Get PID of a process
pidof sshd

List some process 
pgrep -u root | xargs ps -fp
ps -fp $(pgrep -u root)
ps -u avi | grep pstest | awk '{print $1}'


ps [OPTIONS]

ps - Shows the process of current shell

PID - unique process ID
TTY - terminal type of user logged in to
TIME - amount of CPU in min and sec that process has been
running
CMD = name of the command that launched the process

ps -e
ps -ef --detailed form
ps aux --- more detialed form
ps -u  ---which user  running the process
ps -G  ---which group running the process.

pstree â€“ Show process hierarchy
ps -ejH
pstree

pgrep â€“ Find process by name
pgrep ssh      # Get PID of ssh process
pgrep -u user  # Get processes of a user

****************************************************************************************************************
We discussed how there is a TTY field in the ps output. The TTY is the terminal that executed the command.

There are two types of terminals: regular terminal devices and pseudoterminal devices.
 A regular terminal device is a native terminal device that you can type into and send output to your system. 
 This sounds like the terminal application you've been launching to get to your shell, but it's not.
 
****************************************************************************************************************

jobs - Will show active jobs.
bg - Resume jobs to the background.
fg - Resume job to the foreground.

Command	When Used	Behavior
&	At process start	Starts a command directly in background
fg / bg	After process is running/suspended	Switches an existing job between foreground and background

& â€“ Run process in background
./longtask.sh &

example

sleep 10s
ctrl+z
jobs
bg %jobid
fg %jobid

nice
ps -ef
ps -l pid
nice -n -10 /opt/script21.sh

kill â€“ Terminate a process
kill -9 1234    # Kill process with PID 1234 (forcefully)
kill -15 1234   # Kill gracefully (default)

killall â€“ Kill process by name
killall firefox   # Kill all firefox processes

pkill â€“ Kill by name/user
pkill -u user      # Kill all processes of user
pkill -9 nginx     # Force kill nginx
            user process
pkill -9 -u avi pstest.sh

How to Prevent a Process from Dying on SIGHUP
nohup command & â†’ ignores SIGHUP.
disown -h %job â†’ detach job from terminal.
setsid command & â†’ start process in new session, immune to SIGHUP.
tmux / screen â†’ keep terminal session alive.


nohup
If you want your process keep running even after closing your
terminal, you can use nohup

nohup process &
nohup process > /dev/null 2>&1 &

at â€“ Schedule a command once
at 5pm
> echo "Backup done" >> /tmp/log.txt
> <Ctrl+D>
Schedule â†’ at 5pm

List â†’ atq
Inspect â†’ at -c job_id
Delete â†’ atrm job_id


1. nohup (No Hang Up)

ğŸ‘‰ nohup runs a command immune to SIGHUP (so it wonâ€™t die if you log out or close the terminal).
By default, it redirects output to nohup.out.
1.1 Basic usage
nohup ./script.sh &
Runs script.sh in background.
Output goes to nohup.out.
Survives logout.
1.2 Custom output redirection
nohup ./script.sh > mylog.txt 2>&1 &
Output and errors go to mylog.txt.
1.3 Run with nice (lower priority)
nohup nice -n 10 ./heavyjob.sh > out.log 2>&1 &
Runs with lower CPU priority and ignores hangup.
1.4 Run without creating nohup.out
nohup ./script.sh >/dev/null 2>&1 &
No output file created, everything discarded.
1.5 Using setsid with nohup
setsid nohup ./server.sh >/dev/null 2>&1 &

Double protection: detached session (setsid) + ignore hangup (nohup).
ğŸ”¹ 2. disown (Shell job management)
ğŸ‘‰ disown is a shell builtin (Bash/Zsh) that removes jobs from the shellâ€™s job table.
Useful for processes already started in this shell.
2.1 Disown a specific job
./script.sh &
jobs
# [1]+  Running  ./script.sh &
disown %1
Removes job %1 from job list.
Process keeps running but wonâ€™t appear in jobs.
2.2 Disown and protect from SIGHUP
disown -h %1
Removes from jobs and ignores SIGHUP.
2.3 Disown all jobs
disown -a
Removes all jobs from the shellâ€™s job table.
2.4 Disown all jobs and protect from SIGHUP
disown -ah
Detaches all jobs and shields them from SIGHUP.
2.5 Disown a stopped job (after Ctrl+Z)
./script.sh
# Press Ctrl+Z to suspend
bg %1          # resume in background
disown -h %1   # protect from SIGHUP

1. nohup
What it does: Runs a command immune to SIGHUP (hangup) â€” so if you close the terminal, the process keeps running.
Default behavior: Redirects stdout/stderr to nohup.out if not specified.
Example:
nohup python3 myscript.py > output.log 2>&1 &
Runs in background (&), ignores hangups, logs output to output.log.
âœ… Use when: You just want a process to survive logout, donâ€™t care about reconnecting to it later.
2. disown
What it does: Removes a job from the shellâ€™s job table. After this, the process wonâ€™t receive SIGHUP when you close the terminal.
Example:
long_running_task &
disown
First starts the job in background.
Then disown detaches it from your shell.
âœ… Use when: You already started a process and want to â€œfreeâ€ it from your shell without restarting.
3. setsid
What it does: Starts a program in a new session, fully detached from the controlling terminal.
Example:
setsid ./server.sh > server.log 2>&1 &
Runs as its own session leader, immune to hangups.
âœ… Use when: You want a process completely detached (no job control, no need to disown, no output clutter).
4. tmux
What it does: Terminal multiplexer â€” lets you create detachable terminal sessions. You can disconnect and reconnect later.
Example:
tmux new -s mysession
# run your process
# then detach with: Ctrl+b d
tmux attach -t mysession
âœ… Use when: You want to resume interactive sessions later (best for SSH, remote servers, or long-running scripts you want to monitor).
5. screen
What it does: Similar to tmux, but older. Also allows detachable terminal sessions.
Example:
screen -S mysession
# run process
# detach: Ctrl+a d
screen -r mysession
âœ… Use when: You donâ€™t have tmux installed but need detachable sessions. (Many prefer tmux nowadays because itâ€™s more modern and flexible.)
ğŸ”‘ Quick Comparison Table
Command	Keeps running after logout?	Reattach/Resume?	Typical Use Case
nohup	âœ… Yes	âŒ No	Quick background task that must survive logout
disown	âœ… Yes	âŒ No	Free already started job from shell
setsid	âœ… Yes	âŒ No	Fully detached daemon-style processes
tmux	âœ… Yes	âœ… Yes	Interactive sessions you want to resume later
screen	âœ… Yes	âœ… Yes	Same as tmux, but older alternative

ğŸ” 1. strace
What it does: Traces system calls and signals made by a program.
A "system call" is when a program asks the kernel for something (e.g., open a file, read/write, fork, exec, network I/O).
strace ls

2. ltrace
What it does: Traces library function calls made by a program (mainly dynamic libraries like libc.so).
Example: malloc, printf, strcpy, fopen, etc.
ltrace ls


Difference vs Related Commands
Command	Purpose
nice	Start a new process with a given nice value.
renice	Change the priority of an already running process.
psnice	A simpler wrapper to view/change nice values (uses renice internally).
